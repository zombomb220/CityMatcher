
import type { CityState } from '../../types';
import { ResourceType } from '../../types';
import { PRODUCT_PARAMS } from '../../config/buildingStats';

// Contract: Reset Flows. Preserve Stocks.
// Power & Workforce are Flows -> Reset to 0.
// Money, Population, Goods, Products are Stocks -> Persist.
// Also handles Decay of Goods.

export const resetFlows = (currentCity: CityState, trackChange: (res: string, amt: number, src: string) => void): CityState => {
    // 1. Deep Clone (We still need a fresh object for the new turn state)
    // We can optimization this later, but for correctness now, JSON parse is safe for POJOs
    const newCity: CityState = JSON.parse(JSON.stringify(currentCity));

    // 2. Reset Capacities (Flows)
    newCity.powerCapacity = 0;
    newCity.jobsCapacity = 0;

    // Workforce is a capacity generated by population each turn.
    // It resets to 0 here, and will be filled by Production Phase.
    newCity.workforceAvailable = 0;
    newCity.population = 0; // Treat as Scalar (Housing Capacity) per "Scalar" rule, overriding "Persistent Stock" to avoid infinite growth.
    newCity.powerAvailable = 0;

    // 3. Reset Per-Turn Accumulators (for stats)
    // Note: Stock resources (Money, rawGoods, Products) are KEPT.

    // 4. Handle Decay (Stock Logic)
    // Raw Goods decay
    let carriedRawGoods = newCity.rawGoodsAvailable;
    const decay = Math.floor(carriedRawGoods * PRODUCT_PARAMS.decayRate);
    if (decay > 0) {
        carriedRawGoods -= decay;
        newCity.rawGoodsAvailable = carriedRawGoods;
        trackChange(ResourceType.RawGoods, -decay, 'Storage Decay');
    }

    return newCity;
};
